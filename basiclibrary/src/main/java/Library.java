/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import java.io.BufferedReader;
import java.nio.charset.Charset;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.util.*;

/**
 *  A class for CF 401 Lab 02 and Lab03. It's got methods generally related to arrays.
 */
public class Library {

    /**
     * Return an array of size timesToRoll, whose values each represent a
     * value rolled on a six sided die.
     *
     * @param timesToRoll The number of times to roll.
     * @return An array containing the results of rolling the die timesToRoll times.
     */
    protected int[] roll(int timesToRoll) {
        int[] returnArray = new int[timesToRoll];
        Random r = new Random();
        for (int i = 0; i < timesToRoll; i++) {
            returnArray[i] = r.nextInt(6) + 1;
        }
        return returnArray;
    }

    /**
     * Returns a boolean indicating whether array values contains duplicates.
     *
     * @param values The int array to search for duplicates.
     * @return The boolean result, indicating whether array values contains duplicates.
     */
    protected boolean containsDuplicates(int[] values) {
        int currentValue;
        boolean hasDuplicates = false;
        for (int i = 0; i < values.length && !hasDuplicates; i++) {
            currentValue = values[i];
            for (int j = i + 1; j < values.length && !hasDuplicates; j++) {
                if (currentValue == values[j])
                    hasDuplicates = true;
            }
        }
        return hasDuplicates;
    }

    /**
     * Returns the average of the elements in array values.
     *
     * @param values The int array of values for which to calculate the average.
     * @return The average value of the elements in array values.
     */
    protected double calculateAverage(int[] values) {
        int sum = 0;
        for (int i = 0; i < values.length; i++)
            sum += values[i];

        return sum / values.length;
    }

    /**
     * Returns the row in the matrix with the lowest average values.
     * In the event of a tie, the first one is returned.
     *
     * @param matrix The two dimensional array of ints to search.
     * @return The int[] representing the row with the lowest average values.
     */
    protected int[] findLowestAverageValueArray(int[][] matrix) {
        int indexOfRowWithLowestAverage = 0;
        double lowestAverage = 0;
        double currentAverage = 0;
        for (int i = 0; i < matrix.length; i++) {
            currentAverage = this.calculateAverage(matrix[i]);
            if (currentAverage < lowestAverage) {
                lowestAverage = currentAverage;
                indexOfRowWithLowestAverage = i;
            }
        }
        return matrix[indexOfRowWithLowestAverage];
    }

    /**
     * This is a Lab 03 method. Prints out an analysis of hard coded weather data spanning four weeks.
     */
    protected void analyzeMonthlyWeatherData() {
        // Daily average temperatures for Seattle, October 1-28 2017
        int[][] weeklyMonthTemperatures = {
                {66, 64, 58, 65, 71, 57, 60},
                {57, 65, 65, 70, 72, 65, 51},
                {55, 54, 60, 53, 59, 57, 61},
                {65, 56, 55, 52, 55, 62, 57}
        };

        //Load all temps into hash set
        int min = 150;
        int max = -100;
        int aValue;
        HashSet<Integer> hashSet = new HashSet();
        for (int i = 0; i < weeklyMonthTemperatures.length; i++) {
            for (int j = 0; j < weeklyMonthTemperatures[i].length; j++) {
                aValue = weeklyMonthTemperatures[i][j];
                min = (aValue < min) ? (aValue) : (min);
                max = (aValue > max) ? (aValue) : (max);
                hashSet.add(aValue);
            }
        }

        //Identify any temps not in temperature data and load into new hash set
        HashSet<Integer> missingTempsHashSet = new HashSet();
        for (int i = min + 1; i < max; i++) {
            if (!hashSet.contains(i)) {
                missingTempsHashSet.add(i);
            }
        }

        //Print out some analytical information
        System.out.println("High " + max);
        System.out.println("Low " + min);
        for (Integer n : missingTempsHashSet) {
            System.out.println("Never saw temperature: " + n);
        }
    }

    /**
     * This is a lab04 method. It takes in a list of votes and returns who won.
     *
     * @param votes The list of votes to tally.
     * @return The winner.
     */
    protected String tally(List<String> votes) {
        HashMap<String, Integer> hashMap = new HashMap();
        for (String aVote : votes) {
            if (hashMap.containsKey(aVote)) {
                hashMap.put(aVote, hashMap.get(aVote) + 1);
            } else {
                hashMap.put(aVote, 1);
            }
        }

        //TODO Is there a way to cast the iterator declaration <Map.Entry>, rather than casting each instance.
        String winner = null;
        int currentHighTally = 0;
        Map.Entry<String, Integer> pair;
        Iterator it = hashMap.entrySet().iterator();
        while (it.hasNext()) {
            pair = (Map.Entry) it.next();
            if (pair.getValue() > currentHighTally) {
                winner = pair.getKey();
                currentHighTally = pair.getValue();
            }
        }

        return winner;
    }
}
